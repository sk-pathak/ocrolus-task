// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: article_views.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteOldArticleViews = `-- name: DeleteOldArticleViews :exec
DELETE FROM article_views
WHERE article_views.user_id = $1
  AND id NOT IN (
    SELECT id
    FROM article_views
    WHERE user_id = $1
    ORDER BY viewed_at DESC
    LIMIT $2
  )
`

type DeleteOldArticleViewsParams struct {
	UserID int64
	Limit  int32
}

func (q *Queries) DeleteOldArticleViews(ctx context.Context, arg DeleteOldArticleViewsParams) error {
	_, err := q.db.Exec(ctx, deleteOldArticleViews, arg.UserID, arg.Limit)
	return err
}

const getRecentlyViewedArticles = `-- name: GetRecentlyViewedArticles :many
SELECT a.id, a.title, a.content, a.author_id, a.created_at, a.updated_at
FROM article_views av
JOIN articles a ON av.article_id = a.id
WHERE av.user_id = $1
ORDER BY av.viewed_at DESC
LIMIT 15
`

func (q *Queries) GetRecentlyViewedArticles(ctx context.Context, userID int64) ([]Article, error) {
	rows, err := q.db.Query(ctx, getRecentlyViewedArticles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertArticleView = `-- name: UpsertArticleView :exec
INSERT INTO article_views (user_id, article_id, viewed_at)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, article_id)
DO UPDATE SET viewed_at = EXCLUDED.viewed_at
`

type UpsertArticleViewParams struct {
	UserID    int64
	ArticleID int64
	ViewedAt  pgtype.Timestamp
}

func (q *Queries) UpsertArticleView(ctx context.Context, arg UpsertArticleViewParams) error {
	_, err := q.db.Exec(ctx, upsertArticleView, arg.UserID, arg.ArticleID, arg.ViewedAt)
	return err
}
